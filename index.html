<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>VR Cidade Procedural Completa (Gaze Walk)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <style>
    html,body { margin:0; height:100%; background:#000; }
    #ui { position:fixed; top:10px; left:10px; color:#fff; font-family:system-ui, sans-serif; z-index:2; }
    #ui span { display:inline-block; margin-right:12px; }
  </style>
</head>
<body>
<div id="ui">
  <span>Olhe acima do horizonte para andar</span>
  <span>FPS: <b id="fps">--</b></span>
</div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.161.0/build/three.module.js';
import { XRButton } from 'https://unpkg.com/three@0.161.0/examples/jsm/webxr/XRButton.js';

// Cena e render
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x202530);
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1500);
const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: 'high-performance' });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
renderer.xr.enabled = true;
document.body.appendChild(renderer.domElement);
document.body.appendChild(XRButton.createButton(renderer));

// Luzes e ambiente
const hemi = new THREE.HemisphereLight(0xffffff, 0x202020, 0.8);
scene.add(hemi);
const sun = new THREE.DirectionalLight(0xfff6d5, 0.9);
sun.position.set(120, 200, -80);
scene.add(sun);

// Chão base
const ground = new THREE.Mesh(
  new THREE.PlaneGeometry(5000, 5000),
  new THREE.MeshStandardMaterial({ color: 0x2c2c2c, roughness: 1 })
);
ground.rotation.x = -Math.PI/2;
ground.receiveShadow = true;
scene.add(ground);

// Retículo + vignette (opcional)
const reticle = new THREE.Mesh(new THREE.RingGeometry(0.0025, 0.0045, 32), new THREE.MeshBasicMaterial({ color: 0xffffff }));
reticle.position.set(0, 0, -0.6);
camera.add(reticle);
const vignette = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), new THREE.MeshBasicMaterial({ color: 0x000000, opacity: 0.22, transparent: true }));
vignette.position.set(0, 0, -0.9);
vignette.renderOrder = 9999;
vignette.visible = false;
camera.add(vignette);
scene.add(camera);

// Utilidades
const fpsEl = document.getElementById('fps');
const clock = new THREE.Clock();
const tmpV = new THREE.Vector3();

function makeRNG(seedVal=12345){
  const state = { value: seedVal>>>0 };
  return function rng(){
    state.value = (state.value * 1664525 + 1013904223) % 4294967296;
    return state.value / 4294967296;
  };
}

// Pool de móveis
const Furniture = {
  sofa: () => new THREE.Mesh(new THREE.BoxGeometry(2.2,0.9,1.0), new THREE.MeshStandardMaterial({ color: 0x4a4a4a })),
  mesa: () => new THREE.Mesh(new THREE.BoxGeometry(1.4,0.75,1.4), new THREE.MeshStandardMaterial({ color: 0x7a5233 })),
  cadeira: () => new THREE.Mesh(new THREE.BoxGeometry(0.45,0.9,0.45), new THREE.MeshStandardMaterial({ color: 0x364b7a })),
  cama: () => new THREE.Mesh(new THREE.BoxGeometry(2.0,0.6,1.2), new THREE.MeshStandardMaterial({ color: 0x9aa8ff })),
  armario: () => new THREE.Mesh(new THREE.BoxGeometry(1.2,2.0,0.6), new THREE.MeshStandardMaterial({ color: 0xc9c3b8 })),
  balcao: () => new THREE.Mesh(new THREE.BoxGeometry(2.0,1.0,0.8), new THREE.MeshStandardMaterial({ color: 0xbdb7ad })),
  estante: () => new THREE.Mesh(new THREE.BoxGeometry(1.6,1.8,0.4), new THREE.MeshStandardMaterial({ color: 0x6b5f53 }))
};

// Tipos de prédio com interiores
function createBuilding(type, pos, w, d, h, color){
  const shell = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), new THREE.MeshStandardMaterial({ color }));
  shell.position.copy(pos);
  scene.add(shell);

  const floor = new THREE.Mesh(new THREE.PlaneGeometry(w-0.8, d-0.8), new THREE.MeshStandardMaterial({ color: 0xdddddd }));
  floor.rotation.x = -Math.PI/2;
  floor.position.set(pos.x, pos.y - h/2 + 0.02, pos.z);
  scene.add(floor);

  const interior = { loaded: false, items: [], type };
  function add(mesh, x, z, yOffset=0.45){ mesh.position.set(pos.x+x, floor.position.y+yOffset, pos.z+z); interior.items.push(mesh); scene.add(mesh); }

  function load(){
    if (interior.loaded) return;
    interior.loaded = true;
    if (type === 'house'){
      add(Furniture.sofa(), -w*0.25, d*0.25);
      add(Furniture.mesa(), -w*0.1, d*0.1);
      add(Furniture.cadeira(), -w*0.05, d*0.05);
      add(Furniture.cama(), -w*0.25, -d*0.25);
      add(Furniture.armario(), -w*0.4, -d*0.15);
      add(Furniture.balcao(), w*0.25, d*0.2);
      add(Furniture.mesa(), w*0.15, d*0.05);
      add(Furniture.cadeira(), w*0.1, d*0.02);
    } else if (type === 'shop'){
      add(Furniture.balcao(), 0, d*0.2);
      add(Furniture.estante(), -w*0.25, 0);
      add(Furniture.estante(), w*0.25, 0);
      add(Furniture.mesa(), 0, -d*0.1);
    } else if (type === 'office'){
      for (let i=0;i<4;i++){ add(Furniture.mesa(), -w*0.3 + i*(w*0.2), 0); add(Furniture.cadeira(), -w*0.3 + i*(w*0.2), -0.2); }
      add(Furniture.armario(), w*0.35, -d*0.2);
    } else if (type === 'apartment'){
      add(Furniture.sofa(), -w*0.2, d*0.15);
      add(Furniture.mesa(), -w*0.05, d*0.05);
      add(Furniture.cama(), w*0.2, -d*0.2);
      add(Furniture.armario(), w*0.32, -d*0.12);
    }
  }
  function unload(){
    if (!interior.loaded) return;
    interior.loaded = false;
    for (const m of interior.items){ scene.remove(m); m.geometry.dispose(); if (m.material.dispose) m.material.dispose(); }
    interior.items.length = 0;
  }
  return { shell, floor, pos, size:{w,d,h}, load, unload };
}

// Instancing urbano (árvores, postes)
function createInstanced(cityGroup, geo, mat, positions){
  const inst = new THREE.InstancedMesh(geo, mat, positions.length);
  const m = new THREE.Matrix4();
  for (let i=0;i<positions.length;i++){ m.makeTranslation(positions[i].x, positions[i].y, positions[i].z); inst.setMatrixAt(i, m); }
  inst.instanceMatrix.needsUpdate = true;
  cityGroup.add(inst);
  return inst;
}

// Gerador de chunk
function generateChunk(cx, cz, options){
  const group = new THREE.Group();
  group.name = `chunk_${cx}_${cz}`;
  scene.add(group);

  const rng = makeRNG((cx*73856093) ^ (cz*19349663) ^ 12345);
  const originX = cx*options.size;
  const originZ = cz*options.size;

  // Ruas principais
  const roadMat = new THREE.MeshStandardMaterial({ color: 0x1e1e1e });
  const sidewalkMat = new THREE.MeshStandardMaterial({ color: 0x3a3a3a });
  const lane = new THREE.Mesh(new THREE.PlaneGeometry(options.size, 8), roadMat);
  lane.rotation.x = -Math.PI/2; lane.position.set(originX+options.size/2, 0.01, originZ+options.size/2);
  group.add(lane);
  const lane2 = lane.clone(); lane2.geometry = new THREE.PlaneGeometry(8, options.size); group.add(lane2);

  // Calçadas
  const sw1 = new THREE.Mesh(new THREE.PlaneGeometry(options.size, 4), sidewalkMat);
  sw1.rotation.x = -Math.PI/2; sw1.position.set(originX+options.size/2, 0.02, originZ+options.size/2+6); group.add(sw1);
  const sw2 = sw1.clone(); sw2.position.set(originX+options.size/2, 0.02, originZ+options.size/2-6); group.add(sw2);
  const sw3 = new THREE.Mesh(new THREE.PlaneGeometry(4, options.size), sidewalkMat);
  sw3.rotation.x = -Math.PI/2; sw3.position.set(originX+options.size/2+6, 0.02, originZ+options.size/2); group.add(sw3);
  const sw4 = sw3.clone(); sw4.position.set(originX+options.size/2-6, 0.02, originZ+options.size/2); group.add(sw4);

  // Lotes
  const buildings = [];
  const lotOffsets = [
    {x:-30,z:-30},{x:0,z:-30},{x:30,z:-30},
    {x:-30,z:0},{x:30,z:0},
    {x:-30,z:30},{x:0,z:30},{x:30,z:30}
  ];
  for (const off of lotOffsets){
    const lx = originX + options.size/2 + off.x + (rng()-0.5)*6;
    const lz = originZ + options.size/2 + off.z + (rng()-0.5)*6;
    const zonePick = rng();
    let type = 'house', h=6, w=12, d=10, color = new THREE.Color().setHSL(0.55 + rng()*0.1, 0.3 + rng()*0.2, 0.55 + rng()*0.2);
    if (zonePick < 0.25){ type='shop'; h=5; w=14; d=10; color.setHSL(0.1 + rng()*0.05, 0.5, 0.5); }
    else if (zonePick < 0.55){ type='apartment'; h=9 + Math.floor(rng()*6); w=12; d=12; color.setHSL(0.6,0.3,0.45); }
    else if (zonePick < 0.8){ type='office'; h=10 + Math.floor(rng()*10); w=16; d=14; color.setHSL(0.65,0.25,0.4); }
    const b = createBuilding(type, new THREE.Vector3(lx, h/2, lz), w, d, h, color);
    buildings.push(b);
  }

  // Árvores e postes instanciados
  const treePositions = [];
  const lampPositions = [];
  for (let i=0;i<20;i++){
    const tx = originX + options.size/2 + (rng()-0.5)*(options.size-20);
    const tz = originZ + options.size/2 + (rng()-0.5)*(options.size-20);
    treePositions.push(new THREE.Vector3(tx, 0.1, tz));
  }
  for (let i=0;i<12;i++){
    const lx = originX + options.size/2 + (rng()-0.5)*(options.size-12);
    const lz = originZ + options.size/2 + (rng()-0.5)*(options.size-12);
    lampPositions.push(new THREE.Vector3(lx, 0.1, lz));
  }
  const treeGeo = new THREE.ConeGeometry(1.2, 3.0, 6);
  const treeMat = new THREE.MeshStandardMaterial({ color: 0x2c7a3b });
  createInstanced(group, treeGeo, treeMat, treePositions);

  const lampGeo = new THREE.CylinderGeometry(0.1, 0.1, 3.5, 6);
  const lampMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });
  createInstanced(group, lampGeo, lampMat, lampPositions);

  return { group, buildings };
}

// Gerenciador de chunks
const City = {
  size: 100,
  radius: 2, // número de chunks ao redor
  chunks: new Map(),
  ensure(cx, cz){
    const key = `${cx},${cz}`;
    if (this.chunks.has(key)) return this.chunks.get(key);
    const chunk = generateChunk(cx, cz, { size: this.size });
    this.chunks.set(key, chunk);
    return chunk;
  },
  update(rigPos){
    const cx = Math.floor(rigPos.x / this.size);
    const cz = Math.floor(rigPos.z / this.size);
    for (let x = cx - this.radius; x <= cx + this.radius; x++){
      for (let z = cz - this.radius; z <= cz + this.radius; z++){
        this.ensure(x, z);
      }
    }
    // Unload chunks muito longe
    for (const [key, val] of this.chunks){
      const [x,z] = key.split(',').map(Number);
      if (Math.abs(x-cx) > this.radius+1 || Math.abs(z-cz) > this.radius+1){
        scene.remove(val.group);
        // Descarrega interiores
        for (const b of val.buildings){ b.unload(); scene.remove(b.shell); scene.remove(b.floor); b.shell.geometry.dispose(); b.floor.geometry.dispose(); if (b.shell.material.dispose) b.shell.material.dispose(); if (b.floor.material.dispose) b.floor.material.dispose(); }
        this.chunks.delete(key);
      }
    }
  },
  updateInteriors(rigPos){
    for (const { buildings } of this.chunks.values()){
      for (const b of buildings){
        const dist = rigPos.distanceTo(b.pos);
        if (dist < 18) b.load();
        else if (dist > 24) b.unload();
      }
    }
  }
};

// Locomoção por gaze
const walkSpeed = 1.55; // m/s
const tmpDir = new THREE.Vector3();
renderer.setAnimationLoop(() => {
  const dt = clock.getDelta();

  // FPS simples
  if (!renderer._fpsAcc){ renderer._fpsAcc=0; renderer._fpsFrames=0; renderer._fpsLast=performance.now(); }
  renderer._fpsAcc += dt; renderer._fpsFrames++;
  if (performance.now() - renderer._fpsLast > 500){
    fpsEl.textContent = Math.round(renderer._fpsFrames / renderer._fpsAcc);
    renderer._fpsAcc = 0; renderer._fpsFrames = 0; renderer._fpsLast = performance.now();
  }

  const xrCam = renderer.xr.getCamera(camera);
  const rig = xrCam.parent || camera;

  // Atualiza chunks conforme posição
  City.update(rig.position);

  // Gaze: direção de olhar
  tmpDir.set(0,0,-1).applyQuaternion(xrCam.quaternion);
  const shouldWalk = tmpDir.y > -0.1; // limiar de horizonte
  if (shouldWalk){
    const forward = new THREE.Vector3(tmpDir.x, 0, tmpDir.z).normalize();
    rig.position.addScaledVector(forward, walkSpeed * dt);
    // vignette.visible = true; // opcional
  } else {
    // vignette.visible = false;
  }

  // Carrega interiores próximos
  City.updateInteriors(rig.position);

  // Ciclo de ambiente
  updateEnvironment(dt);

  renderer.render(scene, camera);
});

// Ambiente e clima
let worldTime = 0;
function updateEnvironment(dt){
  worldTime += dt;
  const t = (Math.sin(worldTime * 0.02) * 0.5 + 0.5);
  sun.intensity = 0.6 + 0.5 * t;
  hemi.intensity = 0.5 + 0.3 * t;
  scene.background.setHSL(0.6 - 0.15*t, 0.5, 0.2 + 0.25*t);
  if (!scene.fog) scene.fog = new THREE.FogExp2(0x202530, 0.0015);
  scene.fog.density = 0.0012 + 0.0008*t;
}

// Resize
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>

